<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>tauschBar ‚Äì Dashboard</title>
    <link rel="stylesheet" href="../css/main.css" />
    <script src="../js/categories.js"></script>
  </head>
  <body>
    <nav class="app-nav">
      <div class="app-nav-container">
        <a class="brand" href="../index.html">tauschBar</a>
        <div class="nav-links" id="dashboardNav">
          <span id="navUser" style="font-weight: 600;"></span>
          <a href="./dashboard.html">Dashboard</a>
          <a href="./create-entry.html" class="btn-primary-nav" id="navCreateEntry">+ Eintrag erstellen</a>
          <a href="./chat.html" id="navChat">Chat</a>
          <a href="./profile.html" id="navProfile">Profil</a>
          <button id="logoutBtn" class="btn">Logout</button>
          <!-- F√ºr nicht eingeloggte User -->
          <a href="./login.html" class="btn-primary-nav" id="navLogin" style="display: none;">Login</a>
          <a href="./register.html" class="btn" id="navRegister" style="display: none;">Registrieren</a>
        </div>
      </div>
    </nav>

    <div class="page-container">
      <div class="page-header">
        <h1 class="page-title">Dashboard</h1>
        <p class="page-subtitle">Entdecke Angebote und Gesuche in deiner N√§he</p>
      </div>

      <div style="display: flex; gap: 12px; margin-bottom: 32px; flex-wrap: wrap;">
        <button id="onlyMineBtn" class="btn btn-secondary">Nur meine Eintr√§ge</button>
        <button id="showOthersBtn" class="btn btn-primary">Eintr√§ge von anderen</button>
        <button id="showMatchesBtn" class="btn btn-secondary">
          Matches <span id="matchBadge" class="badge badge-primary" style="display: none; margin-left: 4px;">0</span>
        </button>
      </div>

      <div class="app-card" style="margin-bottom: 32px;">
        <h3 style="margin: 0 0 20px 0; font-size: 18px; font-weight: 700;">üîç Suche & Filter</h3>
        
        <div style="display: flex; flex-direction: column; gap: 16px;">
          <div class="form-group">
            <input id="searchInput" placeholder="Suche nach Titel, Angebot oder Gesuch..." style="margin: 0;" />
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
            <div class="form-group" style="margin: 0;">
              <select id="categorySelect">
                <option value="">Alle Kategorien</option>
              </select>
            </div>
            
            <div class="form-group" style="margin: 0;">
              <input id="zipInput" placeholder="PLZ..." />
            </div>
          </div>
        </div>
      </div>

      <div id="matchesSection" style="display: none; margin-bottom: 32px;">
        <h2 id="matchesTitle" style="font-size: 24px; font-weight: 700; margin: 0 0 20px 0;">Matches</h2>
        <ul id="matchesList" class="app-list"></ul>
      </div>

      <h2 style="font-size: 24px; font-weight: 700; margin: 0 0 20px 0;">üìã Eintr√§ge</h2>
      <ul id="list" class="app-list"></ul>
    </div>

    <script>
      const list = document.getElementById('list');
      const searchInput = document.getElementById('searchInput');
      const categorySelect = document.getElementById('categorySelect');
      const onlyMineBtn = document.getElementById('onlyMineBtn');
      const showOthersBtn = document.getElementById('showOthersBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const navUser = document.getElementById('navUser');
      const showMatchesBtn = document.getElementById('showMatchesBtn');
      const matchesTitle = document.getElementById('matchesTitle');
      const matchesList = document.getElementById('matchesList');
      const zipInput = document.getElementById('zipInput');
      const matchBadge = document.getElementById('matchBadge');

      // Standardm√§√üig nur Eintr√§ge von anderen anzeigen
      let showMode = 'others'; // 'others', 'mine', oder 'matches'

      const currentUsername = localStorage.getItem('username');
      const token = localStorage.getItem('token');

      // Login-Check + Navbar-Anzeige
      if (!currentUsername || !token) {
        // Nicht eingeloggt - passe Navigation an
        navUser.style.display = 'none';
        document.getElementById('navCreateEntry').style.display = 'none';
        document.getElementById('navChat').style.display = 'none';
        document.getElementById('navProfile').style.display = 'none';
        document.getElementById('logoutBtn').style.display = 'none';
        
        // Zeige Login/Register stattdessen
        document.getElementById('navLogin').style.display = 'inline';
        document.getElementById('navRegister').style.display = 'inline';
        
        // Verstecke Matches-Button
        const showMatchesBtn = document.getElementById('showMatchesBtn');
        if (showMatchesBtn) {
          showMatchesBtn.style.display = 'none';
        }
        
        // Verstecke "Nur meine Eintr√§ge" Button
        const onlyMineBtn = document.getElementById('onlyMineBtn');
        if (onlyMineBtn) {
          onlyMineBtn.style.display = 'none';
        }
      } else {
        // Eingeloggt - zeige eingeloggte Navigation
        navUser.textContent = `Hallo, ${currentUsername}`;
        navUser.style.display = 'inline';
        document.getElementById('navLogin').style.display = 'none';
        document.getElementById('navRegister').style.display = 'none';
      }

      onlyMineBtn.textContent = `Nur von ${currentUsername}`;

      // Load Categories from categories.js
      function loadCategoryOptions() {
        if (window.CATEGORIES) {
          const currentCat = categorySelect.value;
          categorySelect.innerHTML = '<option value="">Alle Kategorien</option>';
          
          window.CATEGORIES.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.name;
            option.textContent = `${cat.icon} ${cat.name}`;
            categorySelect.appendChild(option);
          });
          
          // Restore previous selection if it exists
          if (currentCat) {
            categorySelect.value = currentCat;
          }
        }
      }

      async function loadEntries() {
        list.innerHTML = '<li>Lade...</li>';

        // Wenn wir im Matches-Modus sind, andere Logik
        if (showMode === 'matches') {
          await loadMatchesInMainList();
          return;
        }

        let entries = [];
        try {
          const params = new URLSearchParams();

          if (searchInput.value) params.set('q', searchInput.value.trim());
          if (categorySelect.value)
            params.set('category', categorySelect.value.trim());
          if (zipInput.value) params.set('zip', zipInput.value.trim());

          const url = `http://localhost:3000/entries?${params.toString()}`;
          const res = await fetch(url);

          entries = await res.json();
        } catch (e) {
          list.innerHTML = '<li>Fehler: Server nicht erreichbar.</li>';
          return;
        }

        // Basisliste je nach Modus filtern
        let visible = entries;
        
        console.log('DEBUG: Total entries:', entries.length);
        console.log('DEBUG: currentUsername:', currentUsername);
        console.log('DEBUG: showMode:', showMode);
        
        if (showMode === 'mine') {
          // Nur meine Eintr√§ge anzeigen
          visible = entries.filter(
            (e) => e.createdBy && e.createdBy.username === currentUsername,
          );
          console.log('DEBUG: My entries filtered:', visible.length);
        } else if (showMode === 'others') {
          // Nur Eintr√§ge von anderen (nicht meine)
          // Wenn kein currentUsername vorhanden, zeige alle
          if (currentUsername) {
            visible = entries.filter(
              (e) => !e.createdBy || e.createdBy.username !== currentUsername,
            );
            console.log('DEBUG: Others entries filtered:', visible.length);
            console.log('DEBUG: Sample entries:', entries.slice(0, 3).map(e => ({
              title: e.title,
              username: e.createdBy?.username
            })));
          } else {
            // Nicht eingeloggt: zeige alle Eintr√§ge
            visible = entries;
            console.log('DEBUG: Not logged in, showing all:', visible.length);
          }
        }

        // Such-/Filterwerte
        // Backend hat schon gefiltert
        const filtered = visible;

        if (!filtered.length) {
          if (showMode === 'others' && currentUsername) {
            list.innerHTML = '<li>üì≠ Aktuell gibt es keine Eintr√§ge von anderen Nutzern.<br><small>Klicke auf "Nur meine Eintr√§ge" um deine eigenen Eintr√§ge zu sehen.</small></li>';
          } else if (showMode === 'mine') {
            list.innerHTML = '<li>üì≠ Du hast noch keine Eintr√§ge erstellt.<br><small>Klicke auf <a href="./create-entry.html">"+ Eintrag erstellen"</a> um einen neuen Eintrag zu erstellen.</small></li>';
          } else {
            list.innerHTML = '<li>üì≠ Keine passenden Eintr√§ge vorhanden.</li>';
          }
          return;
        }

        list.innerHTML = '';

        // Helper function to escape HTML and prevent XSS
        function escapeHtml(text) {
          if (!text) return '';
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        for (const e of filtered) {
          const li = document.createElement('li');

          const authorName =
            e.createdBy && e.createdBy.username ? e.createdBy.username : null;
          const author = authorName ? `von ${escapeHtml(authorName)}` : 'von (unbekannt)';
          const canDelete = authorName && authorName === currentUsername;

          // Bestimme, ob es ein Angebot oder Gesuch ist
          const isOffer = e.entryType === 'offer';
          const typeIcon = isOffer ? 'üéÅ' : 'üîç';
          const typeLabel = isOffer ? 'Angebot' : 'Gesuch';
          const description = isOffer ? e.offerDescription : e.requestDescription;
          
          li.innerHTML = `
            <!-- Titel des Eintrags -->
            <strong>${escapeHtml(e.title)}</strong> (${escapeHtml(e.category)})
            <small>${author}</small><br/>

            <!-- Beschreibung von Angebot und Gesuch -->
            <em>Angebot:</em> ${escapeHtml(e.offerDescription)}<br/>
            <em>Gesuch:</em> ${escapeHtml(e.requestDescription)}<br/>

            <!-- Standort & Erstellungsdatum -->
            <small>üìç PLZ:</small> ${escapeHtml(e.zip) || '-'} |
            <small>üìÖ Erstellt:</small>
            ${new Date(e.createdAt).toLocaleDateString(
              'de-DE',
              { year: 'numeric', month: 'long', day: 'numeric' }
            )}<br/>

            <!-- Aktions-Buttons f√ºr diesen Eintrag -->
            <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">

              <!-- L√∂schen-Button: nur sichtbar, wenn es der eigene Eintrag ist -->
              ${
                canDelete
                  ? `<button class="delBtn" data-id="${e._id}">
                      L√∂schen
                    </button>`
                  : ''
              }

              <!-- Kontakt + Melden: nur bei fremden Eintr√§gen -->
              ${
                !canDelete && e.createdBy?._id
                  ? `
                    <!-- Kontakt-Button: √∂ffnet Chat -->
                    <button
                      class="contactBtn"
                      data-id="${e._id}"
                      data-owner="${e.createdBy._id}"
                    >
                      üí¨ Kontakt
                    </button>

                    <!-- Melden-Button: startet Missbrauchsmeldung -->
                    <button
                      class="reportBtn"
                      data-id="${e._id}"
                    >
                      ‚ö†Ô∏è Melden
                    </button>
                  `
                  : ''
              }

            </div>
          `;

          list.appendChild(li);
        }
      }

      async function loadMatchesInMainList() {
        const token = localStorage.getItem('token');
        if (!token) {
          list.innerHTML = '<li>Bitte einloggen, um Matches zu sehen.</li>';
          return;
        }

        // 1) Alle Entries holen
        let entries = [];
        try {
          const res = await fetch('http://localhost:3000/entries');
          entries = await res.json();
        } catch {
          list.innerHTML = '<li>Fehler: Server nicht erreichbar.</li>';
          return;
        }

        // 2) Nur meine Entries
        const myEntries = entries.filter(
          (e) => e.createdBy && e.createdBy.username === currentUsername,
        );
        if (!myEntries.length) {
          list.innerHTML = '<li>üì≠ Du hast noch keine Eintr√§ge erstellt.<br><small>Erstelle einen Eintrag, um Matches zu finden.</small></li>';
          return;
        }

        // 3) F√ºr jeden meiner Entries: /entries/:id/matches abfragen
        const allMatchEntries = [];
        const matchPairs = [];
        
        for (const e of myEntries) {
          try {
            const r = await fetch(
              `http://localhost:3000/entries/${e._id}/matches`,
              {
                headers: { Authorization: `Bearer ${token}` },
              },
            );
            
            if (!r.ok) {
              console.error(`‚ùå Matches API Fehler f√ºr ${e._id}:`, r.status, r.statusText);
              
              // Bei 401 Unauthorized: Token ung√ºltig -> ausloggen
              if (r.status === 401) {
                console.error('‚ö†Ô∏è Token ung√ºltig - leite zu Login weiter');
                alert('Deine Sitzung ist abgelaufen. Bitte melde dich erneut an.');
                localStorage.removeItem('token');
                localStorage.removeItem('username');
                window.location.href = './login.html';
                return;
              }
              
              continue;
            }
            
            const data = await r.json();
            console.log(`‚úÖ Matches f√ºr "${e.title}":`, data.count, 'gefunden');
            
            if (data.matches && data.matches.length) {
              for (const m of data.matches) {
                allMatchEntries.push(m);
                matchPairs.push({ base: e, match: m });
              }
            }
          } catch (err) {
            console.error(`‚ùå Fehler beim Laden der Matches f√ºr ${e._id}:`, err);
          }
        }

        // 4) Anzeigen
        if (!allMatchEntries.length) {
          list.innerHTML = '<li>üîç Keine Matches gefunden.<br><small>Matches werden gefunden, wenn andere Eintr√§ge in der gleichen Kategorie und PLZ erstellt werden.</small></li>';
          return;
        }

        list.innerHTML = '';

        for (const item of matchPairs) {
          const e = item.match; // Der Match-Eintrag
          const baseEntry = item.base; // Mein Eintrag
          
          const li = document.createElement('li');

          const authorName =
            e.createdBy && e.createdBy.username ? e.createdBy.username : null;
          const author = authorName ? `von ${authorName}` : 'von (unbekannt)';

          // Bestimme, ob es ein Angebot oder Gesuch ist
          const isOffer = e.entryType === 'offer';
          const typeIcon = isOffer ? 'üéÅ' : 'üîç';
          const typeLabel = isOffer ? 'Angebot' : 'Gesuch';
          const description = isOffer ? e.offerDescription : e.requestDescription;
          
          li.innerHTML = `
          <div style="background-color: #f0f9ff; padding: 12px; border-left: 4px solid #3b82f6; margin-bottom: 8px;">
            <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid #ddd;">
              <small style="color: #666;">üí° Match f√ºr deinen Eintrag: <strong>${baseEntry.title}</strong></small>
            </div>
            <strong>${typeIcon} ${e.title}</strong> (${e.category}) <small>${author}</small><br/>
            <em>${typeLabel}:</em> ${description || '-'}<br/>
            <small>üìç PLZ:</small> ${e.zip || '-'} | 
            <small>üìÖ Erstellt:</small> ${new Date(e.createdAt).toLocaleDateString('de-DE', { year: 'numeric', month: 'long', day: 'numeric' })}<br/>
            <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">
              ${e.createdBy?._id ? `<button class="contactBtn" data-id="${e._id}" data-owner="${e.createdBy._id}">üí¨ Kontakt aufnehmen</button>` : ''}
            </div>
          </div>
        `;

          list.appendChild(li);
        }
      }

      async function loadMatchesForMyEntries() {
        const matchesSection = document.getElementById('matchesSection');
        matchesSection.style.display = 'block';
        matchesList.style.display = 'block';
        matchesTitle.style.display = 'block';
        matchesTitle.textContent = 'Matches';
        matchesList.innerHTML = '<li>Lade Matches...</li>';

        const token = localStorage.getItem('token');
        if (!token) {
          matchesList.innerHTML = '<li>Bitte einloggen.</li>';
          return;
        }

        // 1) Alle Entries holen
        let entries = [];
        try {
          const res = await fetch('http://localhost:3000/entries');
          entries = await res.json();
        } catch {
          matchesList.innerHTML = '<li>Fehler: Server nicht erreichbar.</li>';
          return;
        }

        // 2) Nur meine Entries
        const myEntries = entries.filter(
          (e) => e.createdBy && e.createdBy.username === currentUsername,
        );
        if (!myEntries.length) {
          matchesList.innerHTML = '<li>Du hast noch keine Eintr√§ge.</li>';
          return;
        }

        // 3) F√ºr jeden meiner Entries: /entries/:id/matches abfragen
        const allMatches = [];
        for (const e of myEntries) {
          try {
            const r = await fetch(
              `http://localhost:3000/entries/${e._id}/matches`,
              {
                headers: { Authorization: `Bearer ${token}` },
              },
            );
            
            if (!r.ok) {
              console.error(`‚ùå Matches API Fehler f√ºr ${e._id}:`, r.status, r.statusText);
              
              // Bei 401 Unauthorized: Token ung√ºltig -> ausloggen
              if (r.status === 401) {
                console.error('‚ö†Ô∏è Token ung√ºltig - leite zu Login weiter');
                alert('Deine Sitzung ist abgelaufen. Bitte melde dich erneut an.');
                localStorage.removeItem('token');
                localStorage.removeItem('username');
                window.location.href = './login.html';
                return;
              }
              
              continue;
            }
            
            const data = await r.json();
            console.log(`‚úÖ Matches f√ºr "${e.title}":`, data.count, 'gefunden');
            
            if (data.matches && data.matches.length) {
              for (const m of data.matches) {
                allMatches.push({ base: e, match: m });
              }
            }
          } catch (err) {
            console.error(`‚ùå Fehler beim Laden der Matches f√ºr ${e._id}:`, err);
          }
        }

        // Badge aktualisieren (zeigt "neue Matches" im Sinne von "aktuelle Trefferzahl")
        setBadgeCount(allMatches.length);

        // 4) Anzeigen
        if (!allMatches.length) {
          matchesList.innerHTML = '<li>Keine Matches gefunden.</li>';
          return;
        }

        matchesTitle.textContent = `Matches (${allMatches.length})`;
        matchesList.innerHTML = '';

        for (const item of allMatches) {
          const li = document.createElement('li');
          li.innerHTML = `
          <div style="padding:8px; border:1px solid #ccc; margin:8px 0;">
            <strong>Dein Eintrag:</strong> ${item.base.title} (${item.base.category}, ${item.base.zip})<br/>
            <strong>Match:</strong> ${item.match.title} (${item.match.category}, ${item.match.zip})
          </div>
        `;
          matchesList.appendChild(li);
        }
      }

      function getBadgeKey() {
        return `matchBadge_${currentUsername || 'anon'}`;
      }

      function setBadgeCount(n) {
        if (n > 0) {
          matchBadge.style.display = 'inline-block';
          matchBadge.textContent = String(n);
        } else {
          matchBadge.style.display = 'none';
          matchBadge.textContent = '0';
        }
        localStorage.setItem(getBadgeKey(), String(n));
      }

      function loadBadgeCount() {
        const saved = parseInt(localStorage.getItem(getBadgeKey()) || '0', 10);
        setBadgeCount(isNaN(saved) ? 0 : saved);
      }

      async function refreshMatchBadge() {
        const token = localStorage.getItem('token');
        if (!token) return;

        let entries = [];
        try {
          const res = await fetch('http://localhost:3000/entries');
          entries = await res.json();
        } catch {
          return;
        }

        const myEntries = entries.filter(
          (e) => e.createdBy && e.createdBy.username === currentUsername,
        );
        if (!myEntries.length) {
          setBadgeCount(0);
          return;
        }

        let count = 0;

        for (const e of myEntries) {
          try {
            const r = await fetch(
              `http://localhost:3000/entries/${e._id}/matches`,
              {
                headers: { Authorization: `Bearer ${token}` },
              },
            );
            
            if (!r.ok) {
              console.error(`‚ùå Badge: Matches API Fehler f√ºr ${e._id}:`, r.status);
              
              // Bei 401: Silently fail (Badge ist nicht kritisch)
              if (r.status === 401) {
                console.error('‚ö†Ô∏è Badge: Token ung√ºltig');
              }
              
              continue;
            }
            
            const data = await r.json();
            if (data.matches && data.matches.length) {
              count += data.matches.length;
            }
          } catch (err) {
            console.error(`‚ùå Badge: Fehler f√ºr ${e._id}:`, err);
          }
        }

        // Badge zeigt "du hast aktuell X Match-Treffer"
        setBadgeCount(count);
      }

      // Delete (Event-Delegation)
      list.addEventListener('click', async (ev) => {
        const btn = ev.target;
        if (btn.classList.contains('contactBtn')) {
          const entryId = btn.getAttribute('data-id');
          const ownerId = btn.getAttribute('data-owner');

          if (!entryId || !ownerId) {
            alert('Fehler: Entry oder Owner-ID fehlt.');
            return;
          }

          // Pr√ºfe ob User eingeloggt ist
          const token = localStorage.getItem('token');
          if (!token) {
            // Nicht eingeloggt - speichere Return-URL und leite zu Login
            const returnUrl = `./chat.html?entry=${entryId}&partner=${ownerId}`;
            localStorage.setItem('returnUrl', returnUrl);
            alert('Bitte melde dich an, um den Kontakt aufzunehmen.');
            window.location.href = './login.html';
            return;
          }

          // Eingeloggt - gehe direkt zum Chat
          window.location.href = `./chat.html?entry=${entryId}&partner=${ownerId}`;
          return;
        }
        // --- REPORT ---
        if (btn.classList.contains('reportBtn')) {
          const entryId = btn.getAttribute('data-id');
          if (!entryId) {
            alert('Fehler: entryId fehlt (Button hat keine ID).');
            return;
          }

          const reason = prompt(
            'Grund der Meldung (z. B. Spam, Betrug, unangemessen):',
          );
          if (!reason) return;

          const details = prompt('Details (optional):') || '';

          const token = localStorage.getItem('token');
          if (!token) {
            alert('Bitte zuerst einloggen.');
            window.location.href = './login.html';
            return;
          }

          const res = await fetch('http://localhost:3000/reports', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({ entryId, reason, details }),
          });

          const data = await res.json().catch(() => ({}));

          if (!res.ok) {
            alert(
              (data.message || 'Meldung fehlgeschlagen.') +
                (data.error ? `\n\nDetails: ${data.error}` : ''),
            );
            return;
          }

          alert('Danke! Eintrag wurde gemeldet!');
          return;
        }

        if (!btn.classList.contains('delBtn')) return;

        const id = btn.getAttribute('data-id');
        if (!confirm('Eintrag wirklich l√∂schen?')) return;

        const token = localStorage.getItem('token');
        if (!token) {
          alert('Bitte zuerst einloggen.');
          window.location.href = './login.html';
          return;
        }

        const res = await fetch(`http://localhost:3000/entries/${id}`, {
          method: 'DELETE',
          headers: { Authorization: `Bearer ${token}` },
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          alert(data.message || 'L√∂schen fehlgeschlagen.');
          return;
        }

        loadEntries();
      });

      // Logout
      logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('token');
        localStorage.removeItem('username');
        window.location.href = './login.html';
      });

      // Controls
      showMatchesBtn.addEventListener('click', () => {
        showMode = 'matches';
        
        // Button-Styling aktualisieren
        showMatchesBtn.classList.add('btn-primary');
        showMatchesBtn.classList.remove('btn-secondary');
        onlyMineBtn.classList.add('btn-secondary');
        onlyMineBtn.classList.remove('btn-primary');
        showOthersBtn.classList.add('btn-secondary');
        showOthersBtn.classList.remove('btn-primary');
        
        // Matches-Sektion ausblenden, da wir jetzt in der Hauptliste anzeigen
        document.getElementById('matchesSection').style.display = 'none';
        
        loadEntries();
      });

      onlyMineBtn.addEventListener('click', () => {
        showMode = 'mine';
        onlyMineBtn.classList.add('btn-primary');
        onlyMineBtn.classList.remove('btn-secondary');
        showOthersBtn.classList.add('btn-secondary');
        showOthersBtn.classList.remove('btn-primary');
        showMatchesBtn.classList.add('btn-secondary');
        showMatchesBtn.classList.remove('btn-primary');
        
        // Matches-Sektion ausblenden
        document.getElementById('matchesSection').style.display = 'none';
        
        loadEntries();
      });

      showOthersBtn.addEventListener('click', () => {
        showMode = 'others';
        showOthersBtn.classList.add('btn-primary');
        showOthersBtn.classList.remove('btn-secondary');
        onlyMineBtn.classList.add('btn-secondary');
        onlyMineBtn.classList.remove('btn-primary');
        showMatchesBtn.classList.add('btn-secondary');
        showMatchesBtn.classList.remove('btn-primary');
        
        // Matches-Sektion ausblenden
        document.getElementById('matchesSection').style.display = 'none';
        
        loadEntries();
      });

      searchInput.addEventListener('input', loadEntries);
      categorySelect.addEventListener('change', loadEntries);
      zipInput.addEventListener('input', loadEntries);

      // Init
      loadCategoryOptions();
      loadBadgeCount();
      
      // Check URL parameters and pre-fill search/filter fields
      const urlParams = new URLSearchParams(window.location.search);
      
      // Suchbegriff aus URL
      const searchParam = urlParams.get('q') || urlParams.get('search');
      if (searchParam) {
        searchInput.value = searchParam;
        console.log('üîç Suchbegriff aus URL:', searchParam);
      }
      
      // PLZ aus URL
      const zipParam = urlParams.get('zip');
      if (zipParam) {
        zipInput.value = zipParam;
        console.log('üìç PLZ aus URL:', zipParam);
      }
      
      // Kategorie aus URL
      const categoryParam = urlParams.get('category');
      if (categoryParam) {
        // Setze Kategorie nachdem Optionen geladen sind
        setTimeout(() => {
          categorySelect.value = categoryParam;
          console.log('üìÇ Kategorie aus URL:', categoryParam);
          // loadEntries wird unten einmalig aufgerufen
        }, 50);
      }

      // Warte kurz damit Kategorie gesetzt werden kann, dann lade Eintr√§ge
      setTimeout(() => {
        loadEntries();
        refreshMatchBadge();
      }, 100);
    </script>
  </body>
</html>
