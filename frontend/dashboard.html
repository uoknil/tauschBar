<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>tauschBar ‚Äì Dashboard</title>
    <link rel="stylesheet" href="./landing-page.css" />
    <link rel="stylesheet" href="./app-styles.css" />
    <script src="./categories.js"></script>
  </head>
  <body>
    <nav class="app-nav">
      <div class="app-nav-container">
        <a class="brand" href="./dashboard.html">tauschBar</a>
        <div class="nav-links">
          <span id="navUser" style="font-weight: 600;"></span>
          <a href="./dashboard.html">Dashboard</a>
          <a href="./create-entry.html" class="btn-primary-nav">+ Eintrag erstellen</a>
          <a href="./chat.html">Chat</a>
          <a href="./profile.html">Profil</a>
          <button id="logoutBtn" class="btn">Logout</button>
        </div>
      </div>
    </nav>

    <div class="page-container">
      <div class="page-header">
        <h1 class="page-title">Dashboard</h1>
        <p class="page-subtitle">Entdecke Angebote und Gesuche in deiner N√§he</p>
      </div>

      <div style="display: flex; gap: 12px; margin-bottom: 32px; flex-wrap: wrap;">
        <button id="onlyMineBtn" class="btn btn-secondary">Nur meine Eintr√§ge</button>
        <button id="showOthersBtn" class="btn btn-primary">Eintr√§ge von anderen</button>
        <button id="showMatchesBtn" class="btn btn-secondary">
          Matches <span id="matchBadge" class="badge badge-primary" style="display: none; margin-left: 4px;">0</span>
        </button>
      </div>

      <div class="app-card" style="margin-bottom: 32px;">
        <h3 style="margin: 0 0 20px 0; font-size: 18px; font-weight: 700;">üîç Suche & Filter</h3>
        
        <div style="display: flex; flex-direction: column; gap: 16px;">
          <div class="form-group">
            <input id="searchInput" placeholder="Suche nach Titel, Angebot oder Gesuch..." style="margin: 0;" />
          </div>
          
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 16px;">
            <div class="form-group" style="margin: 0;">
              <select id="categorySelect">
                <option value="">Alle Kategorien</option>
              </select>
            </div>
            
            <div class="form-group" style="margin: 0;">
              <input id="zipInput" placeholder="PLZ..." />
            </div>
          </div>
        </div>
      </div>

      <div id="matchesSection" style="display: none; margin-bottom: 32px;">
        <h2 id="matchesTitle" style="font-size: 24px; font-weight: 700; margin: 0 0 20px 0;">Matches</h2>
        <ul id="matchesList" class="app-list"></ul>
      </div>

      <h2 style="font-size: 24px; font-weight: 700; margin: 0 0 20px 0;">üìã Eintr√§ge</h2>
      <ul id="list" class="app-list"></ul>
    </div>

    <script>
      const list = document.getElementById('list');
      const searchInput = document.getElementById('searchInput');
      const categorySelect = document.getElementById('categorySelect');
      const onlyMineBtn = document.getElementById('onlyMineBtn');
      const showOthersBtn = document.getElementById('showOthersBtn');
      const logoutBtn = document.getElementById('logoutBtn');
      const navUser = document.getElementById('navUser');
      const showMatchesBtn = document.getElementById('showMatchesBtn');
      const matchesTitle = document.getElementById('matchesTitle');
      const matchesList = document.getElementById('matchesList');
      const zipInput = document.getElementById('zipInput');
      const matchBadge = document.getElementById('matchBadge');

      // Standardm√§√üig nur Eintr√§ge von anderen anzeigen
      let showMode = 'others'; // 'others' oder 'mine'

      const currentUsername = localStorage.getItem('username');
      const token = localStorage.getItem('token');

      // Login-Check + Navbar-Anzeige
      if (!currentUsername || !token) {
        window.location.href = './login.html';
      } else {
        navUser.textContent = `Hallo, ${currentUsername}`;
      }

      onlyMineBtn.textContent = `Nur von ${currentUsername}`;

      // Load Categories from categories.js
      function loadCategoryOptions() {
        if (window.CATEGORIES) {
          const currentCat = categorySelect.value;
          categorySelect.innerHTML = '<option value="">Alle Kategorien</option>';
          
          window.CATEGORIES.forEach(cat => {
            const option = document.createElement('option');
            option.value = cat.name;
            option.textContent = `${cat.icon} ${cat.name}`;
            categorySelect.appendChild(option);
          });
          
          // Restore previous selection if it exists
          if (currentCat) {
            categorySelect.value = currentCat;
          }
        }
      }

      async function loadEntries() {
        list.innerHTML = '<li>Lade...</li>';

        let entries = [];
        try {
          const params = new URLSearchParams();

          if (searchInput.value) params.set('q', searchInput.value.trim());
          if (categorySelect.value)
            params.set('category', categorySelect.value.trim());
          if (zipInput.value) params.set('zip', zipInput.value.trim());

          const url = `http://localhost:3000/entries?${params.toString()}`;
          const res = await fetch(url);

          entries = await res.json();
        } catch (e) {
          list.innerHTML = '<li>Fehler: Server nicht erreichbar.</li>';
          return;
        }

        // Basisliste je nach Modus filtern
        let visible = entries;
        
        console.log('DEBUG: Total entries:', entries.length);
        console.log('DEBUG: currentUsername:', currentUsername);
        console.log('DEBUG: showMode:', showMode);
        
        if (showMode === 'mine') {
          // Nur meine Eintr√§ge anzeigen
          visible = entries.filter(
            (e) => e.createdBy && e.createdBy.username === currentUsername,
          );
          console.log('DEBUG: My entries filtered:', visible.length);
        } else if (showMode === 'others') {
          // Nur Eintr√§ge von anderen (nicht meine)
          // Wenn kein currentUsername vorhanden, zeige alle
          if (currentUsername) {
            visible = entries.filter(
              (e) => !e.createdBy || e.createdBy.username !== currentUsername,
            );
            console.log('DEBUG: Others entries filtered:', visible.length);
            console.log('DEBUG: Sample entries:', entries.slice(0, 3).map(e => ({
              title: e.title,
              username: e.createdBy?.username
            })));
          } else {
            // Nicht eingeloggt: zeige alle Eintr√§ge
            visible = entries;
            console.log('DEBUG: Not logged in, showing all:', visible.length);
          }
        }

        // Such-/Filterwerte
        // Backend hat schon gefiltert
        const filtered = visible;

        if (!filtered.length) {
          if (showMode === 'others' && currentUsername) {
            list.innerHTML = '<li>üì≠ Aktuell gibt es keine Eintr√§ge von anderen Nutzern.<br><small>Klicke auf "Nur meine Eintr√§ge" um deine eigenen Eintr√§ge zu sehen.</small></li>';
          } else if (showMode === 'mine') {
            list.innerHTML = '<li>üì≠ Du hast noch keine Eintr√§ge erstellt.<br><small>Klicke auf <a href="./create-entry.html">"+ Eintrag erstellen"</a> um einen neuen Eintrag zu erstellen.</small></li>';
          } else {
            list.innerHTML = '<li>üì≠ Keine passenden Eintr√§ge vorhanden.</li>';
          }
          return;
        }

        list.innerHTML = '';

        for (const e of filtered) {
          const li = document.createElement('li');

          const authorName =
            e.createdBy && e.createdBy.username ? e.createdBy.username : null;
          const author = authorName ? `von ${authorName}` : 'von (unbekannt)';
          const canDelete = authorName && authorName === currentUsername;

          li.innerHTML = `
            <!-- Titel des Eintrags -->
            <strong>${e.title}</strong> (${e.category})
            <small>${author}</small><br/>

            <!-- Beschreibung von Angebot und Gesuch -->
            <em>Angebot:</em> ${e.offerDescription}<br/>
            <em>Gesuch:</em> ${e.requestDescription}<br/>

            <!-- Standort & Erstellungsdatum -->
            <small>üìç PLZ:</small> ${e.zip || '-'} |
            <small>üìÖ Erstellt:</small>
            ${new Date(e.createdAt).toLocaleDateString(
              'de-DE',
              { year: 'numeric', month: 'long', day: 'numeric' }
            )}<br/>

            <!-- Aktions-Buttons f√ºr diesen Eintrag -->
            <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">

              <!-- L√∂schen-Button: nur sichtbar, wenn es der eigene Eintrag ist -->
              ${
                canDelete
                  ? `<button class="delBtn" data-id="${e._id}">
                      L√∂schen
                    </button>`
                  : ''
              }

              <!-- Kontakt + Melden: nur bei fremden Eintr√§gen -->
              ${
                !canDelete && e.createdBy?._id
                  ? `
                    <!-- Kontakt-Button: √∂ffnet Chat -->
                    <button
                      class="contactBtn"
                      data-id="${e._id}"
                      data-owner="${e.createdBy._id}"
                    >
                      üí¨ Kontakt
                    </button>

                    <!-- Melden-Button: startet Missbrauchsmeldung -->
                    <button
                      class="reportBtn"
                      data-id="${e._id}"
                    >
                      ‚ö†Ô∏è Melden
                    </button>
                  `
                  : ''
              }

            </div>
          `;


          list.appendChild(li);
        }
      }

      async function loadMatchesForMyEntries() {
        matchesList.style.display = 'block';
        matchesTitle.style.display = 'block';
        matchesTitle.textContent = 'Matches';
        matchesList.innerHTML = '<li>Lade Matches...</li>';

        const token = localStorage.getItem('token');
        if (!token) {
          matchesList.innerHTML = '<li>Bitte einloggen.</li>';
          return;
        }

        // 1) Alle Entries holen
        let entries = [];
        try {
          const res = await fetch('http://localhost:3000/entries');
          entries = await res.json();
        } catch {
          matchesList.innerHTML = '<li>Fehler: Server nicht erreichbar.</li>';
          return;
        }

        // 2) Nur meine Entries
        const myEntries = entries.filter(
          (e) => e.createdBy && e.createdBy.username === currentUsername,
        );
        if (!myEntries.length) {
          matchesList.innerHTML = '<li>Du hast noch keine Eintr√§ge.</li>';
          return;
        }

        // 3) F√ºr jeden meiner Entries: /entries/:id/matches abfragen
        const allMatches = [];
        for (const e of myEntries) {
          try {
            const r = await fetch(
              `http://localhost:3000/entries/${e._id}/matches`,
              {
                headers: { Authorization: `Bearer ${token}` },
              },
            );
            const data = await r.json().catch(() => ({}));
            if (r.ok && data.matches && data.matches.length) {
              for (const m of data.matches) {
                allMatches.push({ base: e, match: m });
              }
            }
          } catch {
            // ignorieren, wir wollen minimal bleiben
          }
        }

        // Badge aktualisieren (zeigt "neue Matches" im Sinne von "aktuelle Trefferzahl")
        setBadgeCount(allMatches.length);

        // 4) Anzeigen
        if (!allMatches.length) {
          matchesList.innerHTML = '<li>Keine Matches gefunden.</li>';
          return;
        }

        matchesTitle.textContent = `Matches (${allMatches.length})`;
        matchesList.innerHTML = '';

        for (const item of allMatches) {
          const li = document.createElement('li');
          li.innerHTML = `
          <div style="padding:8px; border:1px solid #ccc; margin:8px 0;">
            <strong>Dein Eintrag:</strong> ${item.base.title} (${item.base.category}, ${item.base.zip})<br/>
            <strong>Match:</strong> ${item.match.title} (${item.match.category}, ${item.match.zip})
          </div>
        `;
          matchesList.appendChild(li);
        }
      }

      function getBadgeKey() {
        return `matchBadge_${currentUsername || 'anon'}`;
      }

      function setBadgeCount(n) {
        if (n > 0) {
          matchBadge.style.display = 'inline-block';
          matchBadge.textContent = String(n);
        } else {
          matchBadge.style.display = 'none';
          matchBadge.textContent = '0';
        }
        localStorage.setItem(getBadgeKey(), String(n));
      }

      function loadBadgeCount() {
        const saved = parseInt(localStorage.getItem(getBadgeKey()) || '0', 10);
        setBadgeCount(isNaN(saved) ? 0 : saved);
      }

      async function refreshMatchBadge() {
        const token = localStorage.getItem('token');
        if (!token) return;

        let entries = [];
        try {
          const res = await fetch('http://localhost:3000/entries');
          entries = await res.json();
        } catch {
          return;
        }

        const myEntries = entries.filter(
          (e) => e.createdBy && e.createdBy.username === currentUsername,
        );
        if (!myEntries.length) {
          setBadgeCount(0);
          return;
        }

        let count = 0;

        for (const e of myEntries) {
          try {
            const r = await fetch(
              `http://localhost:3000/entries/${e._id}/matches`,
              {
                headers: { Authorization: `Bearer ${token}` },
              },
            );
            const data = await r.json().catch(() => ({}));
            if (r.ok && data.matches && data.matches.length) {
              count += data.matches.length;
            }
          } catch {}
        }

        // Badge zeigt "du hast aktuell X Match-Treffer"
        setBadgeCount(count);
      }

      // Delete (Event-Delegation)
      list.addEventListener('click', async (ev) => {
        const btn = ev.target;
        if (btn.classList.contains('contactBtn')) {
          const entryId = btn.getAttribute('data-id');
          const ownerId = btn.getAttribute('data-owner');

          if (!entryId || !ownerId) {
            alert('Fehler: Entry oder Owner-ID fehlt.');
            return;
          }

          window.location.href = `./chat.html?entry=${entryId}&partner=${ownerId}`;
          return;
        }
        // --- REPORT ---
        if (btn.classList.contains('reportBtn')) {
          const entryId = btn.getAttribute('data-id');
          if (!entryId) {
            alert('Fehler: entryId fehlt (Button hat keine ID).');
            return;
          }

          const reason = prompt(
            'Grund der Meldung (z. B. Spam, Betrug, unangemessen):',
          );
          if (!reason) return;

          const details = prompt('Details (optional):') || '';

          const token = localStorage.getItem('token');
          if (!token) {
            alert('Bitte zuerst einloggen.');
            window.location.href = './login.html';
            return;
          }

          const res = await fetch('http://localhost:3000/reports', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              Authorization: `Bearer ${token}`,
            },
            body: JSON.stringify({ entryId, reason, details }),
          });

          const data = await res.json().catch(() => ({}));

          if (!res.ok) {
            alert(
              (data.message || 'Meldung fehlgeschlagen.') +
                (data.error ? `\n\nDetails: ${data.error}` : ''),
            );
            return;
          }

          alert('Danke! Eintrag wurde gemeldet!');
          return;
        }

        if (!btn.classList.contains('delBtn')) return;

        const id = btn.getAttribute('data-id');
        if (!confirm('Eintrag wirklich l√∂schen?')) return;

        const token = localStorage.getItem('token');
        if (!token) {
          alert('Bitte zuerst einloggen.');
          window.location.href = './login.html';
          return;
        }

        const res = await fetch(`http://localhost:3000/entries/${id}`, {
          method: 'DELETE',
          headers: { Authorization: `Bearer ${token}` },
        });

        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          alert(data.message || 'L√∂schen fehlgeschlagen.');
          return;
        }

        loadEntries();
      });

      // Logout
      logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('token');
        localStorage.removeItem('username');
        window.location.href = './login.html';
      });

      // Controls
      showMatchesBtn.addEventListener('click', () => {
        // beim √ñffnen als "gesehen" markieren
        setBadgeCount(0);
        loadMatchesForMyEntries();
      });

      onlyMineBtn.addEventListener('click', () => {
        showMode = 'mine';
        onlyMineBtn.classList.add('btn-primary');
        onlyMineBtn.classList.remove('btn-secondary');
        showOthersBtn.classList.add('btn-secondary');
        showOthersBtn.classList.remove('btn-primary');
        loadEntries();
      });

      showOthersBtn.addEventListener('click', () => {
        showMode = 'others';
        showOthersBtn.classList.add('btn-primary');
        showOthersBtn.classList.remove('btn-secondary');
        onlyMineBtn.classList.add('btn-secondary');
        onlyMineBtn.classList.remove('btn-primary');
        loadEntries();
      });

      searchInput.addEventListener('input', loadEntries);
      categorySelect.addEventListener('change', loadEntries);
      zipInput.addEventListener('input', loadEntries);

      // Check URL parameters and pre-fill search field
      const urlParams = new URLSearchParams(window.location.search);
      const searchParam = urlParams.get('search');
      if (searchParam) {
        searchInput.value = searchParam;
      }

      // Init
      loadCategoryOptions();
      loadBadgeCount();
      loadEntries();
      refreshMatchBadge();
    </script>
  </body>
</html>
